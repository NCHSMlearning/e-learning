<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Exam - NCHSM</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* --- General and Reset --- */
body { 
    font-family: 'Poppins', sans-serif; 
    background: #F8F9FA; 
    margin: 0; 
    padding: 10px; 
}
/* Disable all forms of selection and context menu for lockdown */
body, .exam-main, .question, .options, .options li, label { user-select: none; }
h1 { text-align: center; color: #073450; margin-bottom: 20px; font-size: 1.8rem; } 

/* --- Main Layout: Grid for Sidebar + Content (Mobile First) --- */
.page-wrapper {
    display: grid;
    grid-template-columns: 1fr; 
    gap: 20px; 
    max-width: 1200px;
    margin: 10px auto;
}
.sidebar {
    background: #fff;
    padding: 15px; 
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
    position: static; 
    top: 20px;
    height: auto;
    order: 2; 
}
.exam-main {
    background: #fff;
    padding: 20px; 
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
    order: 1; 
}

/* --- Desktop/Tablet Layout Adjustment (Min-width 992px) --- */
@media (min-width: 992px) {
    body { padding: 20px; }
    .page-wrapper {
        grid-template-columns: 300px 1fr; 
        gap: 30px;
        margin: 20px auto;
    }
    .sidebar {
        position: sticky; 
        order: 1; 
    }
    .exam-main {
        order: 2;
        padding: 30px;
    }
}

/* --- Question Status Table Styling (Responsive Grid) --- */
.status-title { font-size: 1.1rem; font-weight: 600; color: #073450; margin-bottom: 15px; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px; }
#question-status-table {
    display: grid;
    grid-template-columns: repeat(6, 1fr); 
    gap: 8px; 
}
@media (min-width: 576px) {
    #question-status-table {
        grid-template-columns: repeat(8, 1fr); 
    }
}
@media (min-width: 992px) {
    #question-status-table {
        grid-template-columns: repeat(4, 1fr); 
        gap: 10px;
    }
}
.status-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 45px; 
    background: #F1F5F9;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 0.8rem;
    font-weight: 500;
    color: #475569;
    border: 2px solid #F1F5F9;
}
.status-item:hover { background: #E2E8F0; transform: translateY(-1px); }
.status-item.current { border-color: #0A3D62; background: #E2E8F0; font-weight: 700; }
.status-item.answered { background: #D1FAE5; border-color: #38A169; color: #064E3B; }
.status-item.answered::after { content: '‚úì'; font-size: 1.2rem; margin-top: 3px; color: #38A169; }
.status-number { font-weight: 600; }
.status-item.answered .status-number { display: none; }

/* --- Exam Header/Timer --- */
#timer { font-weight: 600; font-size: 1.1rem; margin-bottom: 15px; color: #DC2626; } 

/* --- Progress and Question Content --- */
#progress { margin-top: 15px; margin-bottom: 10px; color: #475569; font-weight: 500;}
.progress-bar { height: 8px; margin-bottom: 20px; } 
.progress-fill { height: 100%; background: #38A169; width: 0%; transition: width 0.3s ease; }
.question-area { border-top: 1px solid #E2E8F0; padding-top: 20px; }
.question { margin-bottom: 20px; font-size: 1rem; font-weight: 600; color: #073450;}
.options { list-style: none; padding: 0; }
.options li { margin: 10px 0; }
.options label { padding: 10px; border-radius: 6px;}

/* --- Navigation Buttons (Streamlined) --- */
#nav-buttons {
    margin-top: 20px;
    display: flex;
    flex-direction: column; 
    gap: 10px;
    padding-top: 15px;
    border-top: 1px solid #E2E8F0;
}
.left-nav {
    display: flex;
    justify-content: space-between;
    width: 100%;
    justify-content: space-around; 
}
.left-nav button { flex-grow: 1; margin: 0 10px; } 

button {
    padding: 10px 20px; 
    font-size: 0.9rem;
    border-radius: 6px;
    transition: all 0.2s ease; 
}
@media (min-width: 576px) {
    #nav-buttons {
        flex-direction: row; 
        justify-content: space-between;
    }
    .left-nav { width: auto; }
    .left-nav button { margin-right: 10px; }
    button { padding: 12px 25px; font-size: 1rem; }
}
button#submit-exam-btn { background: #DC2626; }
button#submit-exam-btn:hover:enabled { background: #B91C1C; }
button:disabled { background: #94D3A2; cursor: not-allowed; opacity: 0.6; }
button:hover:enabled { background: #2F855A; }
button#submit-exam-btn:disabled { background: #FCA5A5; cursor: not-allowed; box-shadow: none; }

/* --- Messages --- */
#answer-saved { 
    padding: 6px 12px; 
    margin: 10px auto 20px; 
}
#error { color: #EF4444; font-weight: 600; text-align: center; margin-bottom: 15px; }
#final-msg { text-align: center; font-size: 1.3rem; color: #064E3B; margin-top: 30px; }

/* --- Success Screen Styles --- */
.success-screen {
    text-align: center;
    padding: 40px 20px;
    background: linear-gradient(135deg, #D1FAE5 0%, #F0FDF4 100%);
    border-radius: 16px;
    margin: 20px auto;
    max-width: 600px;
    border: 3px solid #38A169;
    box-shadow: 0 10px 40px rgba(5, 150, 105, 0.1);
}

.success-icon {
    font-size: 4rem;
    margin-bottom: 20px;
    animation: successPulse 2s infinite;
}

@keyframes successPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.success-title {
    color: #064E3B;
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 15px;
}

.success-message {
    color: #047857;
    font-size: 1.1rem;
    margin-bottom: 25px;
    line-height: 1.6;
}

.redirect-countdown {
    background: white;
    padding: 15px;
    border-radius: 10px;
    margin: 20px auto;
    max-width: 300px;
    border: 2px solid #38A169;
    font-weight: 600;
    color: #065F46;
}

.redirect-countdown span {
    color: #DC2626;
    font-size: 1.3rem;
    font-weight: 700;
}

.dashboard-link {
    display: inline-block;
    margin-top: 20px;
    padding: 12px 30px;
    background: #38A169;
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    transition: all 0.3s;
}

.dashboard-link:hover {
    background: #2F855A;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(5, 150, 105, 0.3);
}

/* =============================== */
/* --- SUBMISSION MODAL STYLES --- */
/* =============================== */
.modal-overlay {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    z-index: 1000; /* Ensure it's above everything */
    align-items: center;
    justify-content: center;
}
.modal-content {
    background: #fff;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 400px;
    text-align: center;
}
.modal-content h3 {
    color: #DC2626;
    margin-top: 0;
    font-weight: 700;
}
.modal-content p {
    color: #475569;
    font-size: 1rem;
    margin-bottom: 25px;
    font-weight: 500;
}
.modal-buttons button {
    margin: 0 10px;
    padding: 10px 20px;
    font-weight: 600;
    width: 120px; /* Uniform width */
}
#confirm-submit-btn {
    background: #38A169;
}
#confirm-submit-btn:hover {
    background: #2F855A;
}
#cancel-submit-btn {
    background: #E5E7EB;
    color: #475569;
}
#cancel-submit-btn:hover {
    background: #D1D5DB;
}

/* Warning Modal for Page Leave */
.warning-modal {
    background: #FFF7ED;
    border: 3px solid #F59E0B;
}

.warning-icon {
    font-size: 3rem;
    margin-bottom: 15px;
}

.warning-title {
    color: #92400E;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
<div class="page-wrapper">
    <div class="sidebar">
        <div id="timer">Loading timer...</div>
        <div class="status-title">Question Status</div>
        <div id="question-status-table"></div>
    </div>
    
    <div class="exam-main">
        <h1 id="exam-title">Examination</h1>
        
        <div id="progress">
            Question <span id="current">0</span> of <span id="total">0</span>
        </div>
        <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
        
        <div class="question-area">
            <div id="error"></div>
            
            <div id="exam-container">Loading question...</div>
            
            <div id="answer-saved">‚úÖ Answer saved!</div>

            <div id="nav-buttons">
                <div class="left-nav">
                    <button id="prev-btn" disabled>Previous</button>
                    <button id="next-btn" disabled>Next</button>
                </div>
                <button id="submit-exam-btn" disabled>Submit Exam</button>
            </div>
        </div>
        
        <div id="final-msg"></div>
    </div>
</div>

<!-- Submission Confirmation Modal -->
<div id="submission-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Final Submission Confirmation</h3>
        <p id="modal-message">You are about to submit your exam. Please confirm.</p>
        <div class="modal-buttons">
            <button id="cancel-submit-btn">Cancel</button>
            <button id="confirm-submit-btn">Confirm & Submit</button>
        </div>
    </div>
</div>

<!-- Page Leave Warning Modal -->
<div id="page-leave-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content warning-modal">
        <div class="warning-icon">‚ö†Ô∏è</div>
        <h3 class="warning-title">Page Navigation Detected</h3>
        <p>You are attempting to leave the exam page. For exam security purposes, leaving this page will result in automatic submission of your exam.</p>
        <p><strong>This action cannot be undone.</strong></p>
        <div class="modal-buttons">
            <button id="stay-on-page-btn" style="background: #38A169; color: white;">Stay on Exam Page</button>
            <button id="leave-anyway-btn" style="background: #DC2626; color: white;">Submit & Leave Anyway</button>
        </div>
    </div>
</div>

<script>
// --- IMPROVED AUTHENTICATION SYSTEM ---
// FIXED: Better authentication for exam page
function getStudentId() {
    // Try URL parameters first (from dashboard link)
    const params = new URLSearchParams(window.location.search);
    const urlUserId = params.get('user_id');
    
    // Try localStorage next (if coming directly)
    const localUserId = localStorage.getItem('currentUserId');
    
    // Return the first found
    return urlUserId || localUserId;
}

let studentId = getStudentId();

if (!studentId) {
    // Redirect to login with return URL
    const returnUrl = encodeURIComponent(window.location.href);
    window.location.href = `exam_login.html?return=${returnUrl}`;
} else {
    console.log('‚úÖ Student authenticated:', studentId.substring(0, 8) + '...');
    // Also store in localStorage for future use
    localStorage.setItem('currentUserId', studentId);
}

// --- CONFIGURATION ---
const SUPABASE_URL = 'https://lwhtjozfsmbyihenfunw.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx3aHRqb3pmc21ieWloZW5mdW53Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk2NTgxMjcsImV4cCI6MjA3NTIzNDEyN30.7Z8AYvPQwTAEEEhODlW6Xk-IR1FK3Uj5ivZS7P17Wpk';
const REDIRECT_URL = 'https://nakurucollegeofhealthelearning.site/exam_dashboard.html';

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const params = new URLSearchParams(window.location.search);
const EXAM_ID = params.get('exam_id');
let questions = [], currentIndex = 0, duration = 0, timerInterval;
let answers = {}; 
let hasAnsweredAtLeastOne = false; 
let examType = 'EXAM'; // Store exam type globally

// References to the modal elements
const submissionModal = document.getElementById('submission-modal');
const confirmSubmitBtn = document.getElementById('confirm-submit-btn');
const cancelSubmitBtn = document.getElementById('cancel-submit-btn');
const finalSubmitBtn = document.getElementById('submit-exam-btn');
const modalMessage = document.getElementById('modal-message');
const examTitle = document.getElementById('exam-title');
const pageLeaveModal = document.getElementById('page-leave-modal');
const stayOnPageBtn = document.getElementById('stay-on-page-btn');
const leaveAnywayBtn = document.getElementById('leave-anyway-btn');

// --- NAVIGATION FUNCTIONS ---
function nextQuestion() {
    if (currentIndex < questions.length - 1) {
        renderQuestion(currentIndex + 1);
    }
}

function prevQuestion() {
    if (currentIndex > 0) {
        renderQuestion(currentIndex - 1);
    }
}

// --- CORE FUNCTIONS ---
async function initExam() {
    try {
        // Get exam details including exam_type
        const { data: examData, error: examError } = await sb.from('exams')
            .select('exam_name, exam_type, duration_minutes')
            .eq('id', EXAM_ID)
            .single();
        
        if (examError || !examData) { 
            document.getElementById('error').innerText = 'Exam not found'; 
            return; 
        }
        
        // Set exam details
        duration = examData.duration_minutes || 30;
        examType = examData.exam_type || 'EXAM';
        examTitle.textContent = examData.exam_name || 'Examination';
        
        // Load questions from exam_questions table
        const { data: qData, error: qError } = await sb.from('exam_questions')
            .select('*')
            .eq('exam_id', EXAM_ID)
            .order('question_number', { ascending: true });
        
        if (qError || !qData || qData.length === 0) { 
            document.getElementById('exam-container').innerText = 'No questions found or failed to load questions.'; 
            console.error('Question error:', qError);
            return; 
        }
        
        questions = qData;

        await loadExistingAnswers();
        
        document.getElementById('total').innerText = questions.length;
        renderQuestionStatusTable();
        renderQuestion();
        startTimer(duration * 60);
        lockDown();
        
    } catch (err) { 
        console.error('Init exam error:', err); 
        document.getElementById('error').innerText = 'Error loading exam.'; 
    }
}

async function loadExistingAnswers() {
    try {
        const { data, error } = await sb.from('exam_grades')
            .select('question_id, selected_answer')
            .eq('student_id', studentId)
            .eq('exam_id', EXAM_ID);

        if (error) throw error;
        
        if (data && data.length > 0) {
            data.forEach(item => {
                // Only load if an answer was actually selected (not null/skipped)
                if (item.selected_answer !== null) { 
                    answers[item.question_id] = item.selected_answer;
                    hasAnsweredAtLeastOne = true;
                }
            });
            if (hasAnsweredAtLeastOne) {
                finalSubmitBtn.disabled = false;
            }
        }
    } catch (err) {
        console.error('Error loading existing answers:', err);
    }
}
function renderQuestion(index = currentIndex) {
    currentIndex = index;
    const q = questions[currentIndex];
    const container = document.getElementById('exam-container');
    
    // Clear container
    container.innerHTML = '';

    // Create question text
    const questionText = document.createElement('div');
    questionText.className = 'question';
    questionText.innerHTML = `<p><strong>Q${currentIndex + 1}:</strong> ${q.question_text}</p>`;
    container.appendChild(questionText);

    // Create options list
    const ul = document.createElement('ul'); 
    ul.className = 'options';
    
    // Create options array
    const options = [];
    if (q.option_a) options.push({ letter: 'A', text: q.option_a });
    if (q.option_b) options.push({ letter: 'B', text: q.option_b });
    if (q.option_c) options.push({ letter: 'C', text: q.option_c });
    if (q.option_d) options.push({ letter: 'D', text: q.option_d });
    
    // Create radio buttons
    options.forEach(opt => {
        const li = document.createElement('li');
        const radioId = `q${q.id}_${opt.letter}`;
        
        li.innerHTML = `
            <label for="${radioId}">
                <input type="radio" id="${radioId}" name="question_${q.id}" value="${opt.letter}">
                <span>${opt.letter}: ${opt.text}</span>
            </label>
        `; 
        ul.appendChild(li);
    });
    container.appendChild(ul);

    // RESTORE PREVIOUS ANSWER
    if (answers[q.id]) {
        const input = document.querySelector(`input[name="question_${q.id}"][value="${answers[q.id]}"]`);
        if (input) {
            input.checked = true;
            console.log(`Restored answer for Q${currentIndex + 1}: ${answers[q.id]}`);
        }
    }

    // Update UI
    updateProgressUI();
    updateStatusTableUI();

    // FIXED: Add event listeners PROPERLY
    setTimeout(() => {
        const radios = document.querySelectorAll(`input[name="question_${q.id}"]`);
        console.log(`Found ${radios.length} radio buttons for Q${currentIndex + 1}`);
        
        radios.forEach(r => {
            // Remove any existing listeners first
            const newRadio = r.cloneNode(true);
            r.parentNode.replaceChild(newRadio, r);
            
            // Add new event listener
            newRadio.addEventListener('change', (event) => { 
                console.log(`Radio changed for Q${currentIndex + 1}:`, event.target.value);
                saveAnswer(event.target.value);
                if (!hasAnsweredAtLeastOne) {
                    hasAnsweredAtLeastOne = true;
                    finalSubmitBtn.disabled = false;
                }
                updateStatusTableUI(); 
            });
        });
    }, 100); // Small delay to ensure DOM is ready
}

// --- STATUS TABLE FUNCTIONS ---
function renderQuestionStatusTable() {
    const tableEl = document.getElementById('question-status-table');
    tableEl.innerHTML = '';

    questions.forEach((q, index) => {
        const item = document.createElement('div');
        item.className = 'status-item';
        item.id = `q-status-${index}`;
        item.innerHTML = `<span class="status-number">${index + 1}</span>`;
        item.dataset.index = index;
        
        item.addEventListener('click', () => {
            renderQuestion(index);
        });

        tableEl.appendChild(item);
    });

    updateStatusTableUI();
}

function updateStatusTableUI() {
    questions.forEach((q, index) => {
        const item = document.getElementById(`q-status-${index}`);
        if (!item) return;

        item.classList.remove('current', 'answered');

        if (index === currentIndex) {
            item.classList.add('current');
        }

        if (answers.hasOwnProperty(q.id) && answers[q.id] !== null) {
            item.classList.add('answered');
        }
    });
}

function updateProgressUI() {
    document.getElementById('current').innerText = currentIndex + 1;
    
    const progressPercent = ((currentIndex + 1) / questions.length) * 100;
    document.getElementById('progress-fill').style.width = progressPercent + '%';

    document.getElementById('prev-btn').disabled = (currentIndex === 0);
    document.getElementById('next-btn').disabled = (currentIndex === questions.length - 1);
}

// --- PERSISTENCE AND SUBMISSION ---
async function saveAnswer(selectedAnswerValue) {
    const q = questions[currentIndex];
    const answer = selectedAnswerValue;
    
    console.log('=== SAVE ANSWER DEBUG ===');
    console.log('Question:', currentIndex + 1);
    console.log('Question ID:', q.id);
    console.log('Selected Answer:', answer);
    console.log('Correct Answer:', q.correct_answer);
    
    answers[q.id] = answer; 

    // Show save confirmation
    document.getElementById('answer-saved').style.display = 'block';
    setTimeout(() => { 
        document.getElementById('answer-saved').style.display = 'none'; 
    }, 1000);

    // Calculate marks based on correct answer
    const marks = answer === q.correct_answer ? (q.marks || 1) : 0;
    console.log('Marks calculated:', marks);
    
    try {
        console.log('Attempting to save to database...');
        const { data, error } = await sb.from('exam_grades').upsert(
            [{
                student_id: studentId, 
                exam_id: EXAM_ID, 
                question_id: q.id, 
                selected_answer: answer, 
                marks, 
                graded_at: new Date()
            }],
            { onConflict: ['student_id', 'exam_id', 'question_id'] }
        );
        
        if (error) {
            console.error('‚ùå Database save error:', error);
            document.getElementById('error').innerText = 'Warning: Could not save answer to server!';
        } else {
            console.log('‚úÖ Answer saved successfully to database');
        }
    } catch (err) { 
        console.error('Error saving answer', err);
        document.getElementById('error').innerText = 'Warning: Could not save answer to server!';
    }
}

function submitExam() {
    let skippedCount = 0;
    
    // Count skipped questions
    questions.forEach(q => {
        if (!answers.hasOwnProperty(q.id) || answers[q.id] === null) {
            skippedCount++;
        }
    });

    let message = `You are about to submit your ${examType} exam. Please confirm.`;

    if (skippedCount > 0) {
        message += ` <br><br><strong style="color:#DC2626;">‚ö†Ô∏è Warning:</strong> You have <strong>${skippedCount}</strong> unanswered question(s). These will be marked as incorrect (0 marks).`;
    } else {
        message += ` <br><br>‚úÖ All ${questions.length} questions have been answered.`;
    }
    
    modalMessage.innerHTML = message;
    submissionModal.style.display = 'flex';
}

// MAIN SUBMISSION FUNCTION
async function executeSubmission() {
    // Disable all buttons to prevent double-clicks
    document.querySelectorAll('button').forEach(btn => btn.disabled = true);
    submissionModal.style.display = 'none';
    
    showSuccessScreen('submitting');

    // Save all unanswered questions as 0 marks
    const skippedEntries = [];
    questions.forEach(q => {
        const questionId = q.id;
        if (!answers.hasOwnProperty(questionId) || answers[questionId] === null) {
            skippedEntries.push({
                student_id: studentId, 
                exam_id: EXAM_ID, 
                question_id: questionId, 
                selected_answer: null, 
                marks: 0, 
                graded_at: new Date()
            });
        }
    });

    if (skippedEntries.length > 0) {
        const { error } = await sb.from('exam_grades').upsert(skippedEntries, { onConflict: ['student_id', 'exam_id', 'question_id'] });
        if (error) {
            console.error('Error saving skipped answers:', error);
        }
    }
    
    // Calculate and save final grade based on exam type
    await calculateAndSaveFinalGrade();
    
    // Update success screen
    showSuccessScreen('completed');
    
    // Countdown before redirect
    let countdown = 5;
    const countdownElement = document.querySelector('#countdown-number');
    const countdownInterval = setInterval(() => {
        countdown--;
        if (countdownElement) countdownElement.textContent = countdown;
        if (countdown <= 0) {
            clearInterval(countdownInterval);
            redirectToDashboard();
        }
    }, 1000);
}

// Show beautiful success screen
function showSuccessScreen(status) {
    clearInterval(timerInterval);
    window.removeEventListener('beforeunload', beforeUnloadHandler);
    
    const container = document.getElementById('exam-container');
    const navButtons = document.getElementById('nav-buttons');
    const progress = document.getElementById('progress');
    const answerSaved = document.getElementById('answer-saved');
    const timer = document.getElementById('timer');
    const finalMsg = document.getElementById('final-msg');
    
    // Hide exam elements
    container.style.display = 'none';
    navButtons.style.display = 'none';
    progress.style.display = 'none';
    answerSaved.style.display = 'none';
    timer.style.display = 'none';
    finalMsg.style.display = 'none';
    
    let title, message, details;
    
    if (status === 'submitting') {
        title = "‚è≥ Processing Submission";
        message = "Your exam is being submitted. Please wait while we process your answers and calculate your grade.";
        details = "Saving responses to database...";
    } else {
        title = "üéâ Exam Successfully Submitted!";
        message = `Congratulations! Your ${examType} has been successfully submitted and graded.`;
        details = "Your results have been saved and are now available in your dashboard.";
    }
    
    const successHTML = `
        <div class="success-screen">
            <div class="success-icon">${status === 'submitting' ? '‚è≥' : '‚úÖ'}</div>
            <h2 class="success-title">${title}</h2>
            <p class="success-message">${message}</p>
            <p style="color: #475569; margin-bottom: 20px;">${details}</p>
            
            <div class="redirect-countdown">
                <p>You will be redirected to your dashboard in <span id="countdown-number">5</span> seconds...</p>
            </div>
            
            <p style="margin-top: 20px; color: #64748B;">
                <small>Exam ID: ${EXAM_ID.substring(0, 8)}... | Student: ${studentId.substring(0, 8)}...</small>
            </p>
            
            <a href="${REDIRECT_URL}?exam_completed=${EXAM_ID}&type=${examType}" class="dashboard-link">
                Go to Dashboard Now
            </a>
        </div>
    `;
    
    document.querySelector('.question-area').insertAdjacentHTML('beforeend', successHTML);
}

function redirectToDashboard() {
    window.location.href = `${REDIRECT_URL}?exam_completed=${EXAM_ID}&type=${examType}`;
}

// CRITICAL FUNCTION: Calculate and save grade based on exam type
async function calculateAndSaveFinalGrade() {
    try {
        // Get all answers for this exam
        const { data: allAnswers } = await sb.from('exam_grades')
            .select('marks')
            .eq('student_id', studentId)
            .eq('exam_id', EXAM_ID);
        
        if (!allAnswers || allAnswers.length === 0) {
            console.log('No answers found to calculate grade');
            return;
        }

        // Calculate total marks (sum of all question marks)
        const totalMarks = allAnswers.reduce((sum, answer) => sum + (answer.marks || 0), 0);
        
        console.log(`üìä Calculating grade for ${examType}: ${totalMarks} total marks`);
        
        // Calculate percentage and prepare grade data based on exam type
        let percentage = 0;
        let gradeData = {
            student_id: studentId,
            exam_id: EXAM_ID,
            question_id: '00000000-0000-0000-0000-000000000000', // Special ID for total
            total_score: 0,
            result_status: 'Final',
            graded_at: new Date().toISOString(),
            graded_by: 'system_auto_grade' // Indicates auto-graded by system
        };

        if (examType === 'CAT_1' || examType === 'CAT') {
            // CAT 1 or generic CAT: out of 30 marks
            percentage = ((totalMarks / 30) * 100);
            gradeData.cat_1_score = totalMarks;
            gradeData.total_score = parseFloat(percentage.toFixed(2));
            console.log(`‚úÖ CAT 1 Grade: ${totalMarks}/30 = ${gradeData.total_score}%`);
            
        } else if (examType === 'CAT_2') {
            // CAT 2: out of 30 marks
            percentage = ((totalMarks / 30) * 100);
            gradeData.cat_2_score = totalMarks;
            gradeData.total_score = parseFloat(percentage.toFixed(2));
            console.log(`‚úÖ CAT 2 Grade: ${totalMarks}/30 = ${gradeData.total_score}%`);
            
        } else if (examType === 'EXAM') {
            // Final Exam: out of 100 marks (for just the exam portion)
            percentage = ((totalMarks / 100) * 100);
            gradeData.exam_score = totalMarks;
            gradeData.total_score = parseFloat(percentage.toFixed(2));
            console.log(`‚úÖ Final Exam Grade: ${totalMarks}/100 = ${gradeData.total_score}%`);
            
        } else if (examType === 'ASSIGNMENT') {
            // Assignment: store in appropriate field
            percentage = ((totalMarks / 100) * 100);
            gradeData.total_score = parseFloat(percentage.toFixed(2));
            console.log(`‚úÖ Assignment Grade: ${totalMarks}/100 = ${gradeData.total_score}%`);
        }

        // Save the final grade to exam_grades table
        const { error: gradeError } = await sb.from('exam_grades').upsert(
            [gradeData],
            { onConflict: ['student_id', 'exam_id', 'question_id'] }
        );

        if (gradeError) {
            console.error('‚ùå Error saving final grade:', gradeError);
            
            // Try alternative: Direct update to student's grade record
            await updateStudentGradeDirectly(gradeData);
        } else {
            console.log('‚úÖ Final grade saved successfully to database');
            
            // Also update the student's overall record if needed
            await updateStudentGradeRecord(gradeData);
        }
        
    } catch (error) {
        console.error('‚ùå Error calculating final grade:', error);
    }
}

// Backup function if main save fails
async function updateStudentGradeDirectly(gradeData) {
    try {
        // Try to update existing grade record
        const { error } = await sb.from('exam_grades')
            .update(gradeData)
            .eq('student_id', studentId)
            .eq('exam_id', EXAM_ID)
            .eq('question_id', '00000000-0000-0000-0000-000000000000');
            
        if (error) {
            // Try insert instead
            const { error: insertError } = await sb.from('exam_grades')
                .insert([gradeData]);
                
            if (insertError) {
                console.error('Both update and insert failed:', insertError);
            }
        }
    } catch (err) {
        console.error('Direct update failed:', err);
    }
}

// Update student's consolidated grade record
async function updateStudentGradeRecord(gradeData) {
    try {
        console.log('üìù Student grade processed:', gradeData);
    } catch (error) {
        console.error('Error updating student record:', error);
    }
}

// --- TIMER AND LOCKDOWN ---
function startTimer(seconds) {
    const timerEl = document.getElementById('timer');
    function updateTimer() {
        const m = Math.floor(seconds / 60), s = seconds % 60;
        const timeString = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        timerEl.innerText = `Time Remaining: ${timeString}`;
        if (seconds-- <= 0) {
            // Timer expiry triggers submission automatically
            showTimeoutMessage();
            setTimeout(executeSubmission, 2000);
            return;
        }
    }
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
}

function showTimeoutMessage() {
    const container = document.getElementById('exam-container');
    container.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; background: #FEF3C7; border-radius: 12px; border: 3px solid #F59E0B;">
            <div style="font-size: 3rem; margin-bottom: 20px;">‚è∞</div>
            <h3 style="color: #92400E;">Time's Up!</h3>
            <p>Your exam time has expired. The system is now automatically submitting your answers.</p>
            <p><strong>Please wait while we process your submission...</strong></p>
        </div>
    `;
}

function lockDown() {
    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('copy', e => e.preventDefault());
    document.addEventListener('cut', e => e.preventDefault());
    document.addEventListener('paste', e => e.preventDefault());
    document.addEventListener('selectstart', e => e.preventDefault());
    
    // Improved page leave handling
    let isSubmitting = false;
    
    window.addEventListener('beforeunload', (e) => {
        if (isSubmitting) return; // Allow redirect if we're submitting
        
        e.preventDefault();
        e.returnValue = 'Are you sure you want to leave? Your exam will be automatically submitted.';
        
        // Show custom modal for better UX
        pageLeaveModal.style.display = 'flex';
        
        // Don't prevent default if user confirms
        stayOnPageBtn.onclick = () => {
            pageLeaveModal.style.display = 'none';
        };
        
        leaveAnywayBtn.onclick = () => {
            isSubmitting = true;
            pageLeaveModal.style.display = 'none';
            executeSubmission();
        };
        
        // Set timeout to auto-submit after 5 seconds
        setTimeout(() => {
            if (pageLeaveModal.style.display === 'flex') {
                pageLeaveModal.style.display = 'none';
                executeSubmission();
            }
        }, 5000);
        
        return e.returnValue;
    });
    
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && !isSubmitting) {
            // Show warning and submit if user switches tabs
            setTimeout(() => {
                if (document.hidden) {
                    alert('‚ö†Ô∏è Exam Security Alert: Tab switching detected. Your exam is being submitted automatically.');
                    executeSubmission();
                }
            }, 1000);
        }
    });
}

// --- EVENT LISTENERS ---
document.getElementById('prev-btn').addEventListener('click', prevQuestion);
document.getElementById('next-btn').addEventListener('click', nextQuestion);
finalSubmitBtn.addEventListener('click', submitExam);
confirmSubmitBtn.addEventListener('click', executeSubmission);
cancelSubmitBtn.addEventListener('click', () => {
    submissionModal.style.display = 'none';
});

window.addEventListener('DOMContentLoaded', initExam);
</script>
</body>
</html>
